// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"strings"
)

func main() {
	flag.Parse()
	for _, filename := range flag.Args() {
		if !strings.HasSuffix(filename, ".go") {
			fmt.Fprintf(os.Stderr, "not a .go file: %s\n", filename)
			os.Exit(1)
		}
		nfilename := filename[:len(filename)-3] + ".wrap.go"

		code, err := ioutil.ReadFile(filename)
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(1)
		}

		// Process the file one line at a time.
		lines := bytes.Split(code, []byte("\n"))

		// Emit prologue.
		var out bytes.Buffer
		fmt.Fprintf(&out, `// Generated by genwrap.go. DO NOT EDIT

package z3

import "runtime"

/*
#cgo LDFLAGS: -lz3
#include <z3.h>
#include <stdlib.h>
*/
import "C"

`)

		// Process lines.
		doc := [][]byte{}
		for i, line := range lines {
			if len(line) >= 2 && line[0] == '/' && line[1] == '/' {
				label := fmt.Sprintf("%s:%d", filename, i+1)
				process(&out, line, doc, label)
				doc = append(doc, line)
			} else {
				doc = nil
			}
		}

		// Produce the output code.
		ncode, err := format.Source(out.Bytes())
		if err != nil {
			fmt.Fprintln(os.Stderr, out.String())
			fmt.Fprintln(os.Stderr, err)
			os.Exit(1)
		}
		if err := ioutil.WriteFile(nfilename, ncode, 0666); err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(1)
		}
	}
}

type directive struct {
	goFn, cFn     string
	goArgs, cArgs []arg
	isDDD         bool
}

type arg struct {
	name, typ string
}

func parseDirective(parts []string) *directive {
	defType := "*Expr"

	colon, cPos := -1, 2
	for i, p := range parts {
		if p == ":" {
			colon, cPos = i, i+1
			break
		}
	}

	dir := &directive{
		goFn: parts[1], cFn: parts[cPos],
	}

	cArgs := parts[cPos+1:]
	goArgs := cArgs
	if colon >= 0 {
		goArgs = parts[2:colon]
	}

	if strings.HasSuffix(goArgs[len(goArgs)-1], "...") {
		dir.isDDD = true
	}

	dir.goArgs = parseArgs(goArgs, defType)
	dir.cArgs = parseArgs(cArgs, "")

	return dir
}

func parseArgs(args []string, defType string) []arg {
	out := make([]arg, 0, len(args))
	for _, a := range args {
		if i := strings.Index(a, ":"); i >= 0 {
			out = append(out, arg{a[:i], a[i+1:]})
		} else {
			out = append(out, arg{a, defType})
		}
	}
	return out
}

func process(w *bytes.Buffer, line []byte, doc [][]byte, label string) {
	if !bytes.Contains(line, []byte("//wrap:expr")) {
		return
	}
	parts := strings.Fields(string(line))
	if parts[0] != "//wrap:expr" {
		return
	}

	// Found wrap directive.
	dir := parseDirective(parts)

	// Function documentation.
	if len(doc) > 0 && string(doc[len(doc)-1]) == "//" {
		doc = doc[:len(doc)-1]
	}
	for _, line := range doc {
		fmt.Fprintf(w, "%s\n", line)
	}

	// Function declaration.
	fmt.Fprintf(w, "func (%s %s) %s(", dir.goArgs[0].name, dir.goArgs[0].typ, dir.goFn)
	for i, a := range dir.goArgs[1:] {
		if i > 0 {
			fmt.Fprintf(w, ", ")
		}
		fmt.Fprintf(w, "%s %s", a.name, a.typ)
	}
	fmt.Fprintf(w, ") *Expr {\n")
	fmt.Fprintf(w, " // Generated from %s.\n", label)

	if dir.goArgs[0].typ != "*Context" {
		// Context is implied by the receiver.
		fmt.Fprintf(w, " ctx := %s.ctx\n", dir.goArgs[0].name)
	}

	if dir.isDDD {
		// Convert arguments to C array.
		ddd := dir.cArgs[len(dir.cArgs)-1].name
		ddd = ddd[:len(ddd)-3]
		fmt.Fprintf(w, " cargs := make([]C.Z3_ast, len(%s)+%d)\n", ddd, len(dir.cArgs)-1)
		for i, arg := range dir.cArgs[:len(dir.cArgs)-1] {
			fmt.Fprintf(w, " cargs[%d] = %s.c\n", i, arg.name)
		}
		fmt.Fprintf(w, " for i, arg := range %s { cargs[i+%d] = arg.c }\n", ddd, len(dir.cArgs)-1)
	}

	// Construct the AST.
	fmt.Fprintf(w, " var cexpr C.Z3_ast\n")
	fmt.Fprintf(w, " ctx.do(func() {\n")
	fmt.Fprintf(w, "  cexpr = C.%s(ctx.c", dir.cFn)
	if !dir.isDDD {
		for _, a := range dir.cArgs {
			if a.typ == "" {
				fmt.Fprintf(w, ", %s.c", a.name)
			} else {
				fmt.Fprintf(w, ", C.%s(%s)", a.typ, a.name)
			}
		}
	} else {
		fmt.Fprintf(w, ", C.uint(len(cargs)), &cargs[0]")
	}
	fmt.Fprintf(w, ")\n")
	fmt.Fprintf(w, " })\n")

	// Keep arguments alive.
	if !dir.isDDD {
		for _, a := range dir.goArgs {
			if a.typ[0] == '*' && a.name != "ctx" {
				fmt.Fprintf(w, " runtime.KeepAlive(%s)\n", a.name)
			}
		}
	} else {
		fmt.Fprintf(w, " runtime.KeepAlive(&cargs[0])\n")
	}

	// Wrap the final C result in a Go result.
	fmt.Fprintf(w, " return wrapExpr(ctx, cexpr)\n")
	fmt.Fprintf(w, "}\n")
	fmt.Fprintf(w, "\n")
}
