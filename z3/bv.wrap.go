// Generated by genwrap.go. DO NOT EDIT

package z3

import "runtime"

/*
#cgo LDFLAGS: -lz3
#include <z3.h>
#include <stdlib.h>
*/
import "C"

// BVNot returns the bit-wise negation of l.
//
// l must have bit-vector sort.
func (l *Expr) BVNot() *Expr {
	// Generated from bv.go:31.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvnot(ctx.c, l.c)
	})
	runtime.KeepAlive(l)
	return wrapExpr(ctx, cexpr)
}

// BVAnd returns the bit-wise and of l and r.
//
// l and r must have the same bit-vector sort.
func (l *Expr) BVAnd(r *Expr) *Expr {
	// Generated from bv.go:37.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvand(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// BVOr returns the bit-wise or of l and r.
//
// l and r must have the same bit-vector sort.
func (l *Expr) BVOr(r *Expr) *Expr {
	// Generated from bv.go:43.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvor(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// BVXor returns the bit-wise xor of l and r.
//
// l and r must have the same bit-vector sort.
func (l *Expr) BVXor(r *Expr) *Expr {
	// Generated from bv.go:49.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvxor(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// BVNand returns the bit-wise nand of l and r.
//
// l and r must have the same bit-vector sort.
func (l *Expr) BVNand(r *Expr) *Expr {
	// Generated from bv.go:55.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvnand(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// BVNor returns the bit-wise nor of l and r.
//
// l and r must have the same bit-vector sort.
func (l *Expr) BVNor(r *Expr) *Expr {
	// Generated from bv.go:61.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvnor(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// BVXnor returns the bit-wise xnor of l and r.
//
// l and r must have the same bit-vector sort.
func (l *Expr) BVXnor(r *Expr) *Expr {
	// Generated from bv.go:67.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvxnor(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// BVNeg returns the two's complement negation of l.
//
// l must have bit-vector sort.
func (l *Expr) BVNeg() *Expr {
	// Generated from bv.go:73.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvneg(ctx.c, l.c)
	})
	runtime.KeepAlive(l)
	return wrapExpr(ctx, cexpr)
}

// BVAdd returns the two's complement sum of l and r.
//
// l and r must have the same bit-vector sort.
func (l *Expr) BVAdd(r *Expr) *Expr {
	// Generated from bv.go:79.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvadd(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// BVSub returns the two's complement subtraction l minus r.
//
// l and r must have the same bit-vector sort.
func (l *Expr) BVSub(r *Expr) *Expr {
	// Generated from bv.go:85.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvsub(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// BVMul returns the two's complement product of l and r.
//
// l and r must have the same bit-vector sort.
func (l *Expr) BVMul(r *Expr) *Expr {
	// Generated from bv.go:91.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvmul(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// BVUDiv returns the unsigned division of l over r.
//
// l and r must have the same bit-vector sort.
func (l *Expr) BVUDiv(r *Expr) *Expr {
	// Generated from bv.go:97.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvudiv(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// BVSDiv returns the two's complement signed division of l over r.
//
// l and r must have the same bit-vector sort.
func (l *Expr) BVSDiv(r *Expr) *Expr {
	// Generated from bv.go:103.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvsdiv(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// BVURem returns the unsigned remainder of l divided by r.
//
// l and r must have the same bit-vector sort.
func (l *Expr) BVURem(r *Expr) *Expr {
	// Generated from bv.go:109.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvurem(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// BVSRem returns the two's complement signed remainder of l divided by r.
//
// The sign of the result follows the sign of l.
//
// l and r must have the same bit-vector sort.
func (l *Expr) BVSRem(r *Expr) *Expr {
	// Generated from bv.go:117.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvsrem(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// BVSMod returns the two's complement signed modulus of l divided by r.
//
// The sign of the result follows the sign of r.
//
// l and r must have the same bit-vector sort.
func (l *Expr) BVSMod(r *Expr) *Expr {
	// Generated from bv.go:125.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvsmod(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// BVULT returns the l < r, where l and r are unsigned.
//
// l and r must have the same bit-vector sort.
func (l *Expr) BVULT(r *Expr) *Expr {
	// Generated from bv.go:131.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvult(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// BVSLT returns the l < r, where l and r are signed.
//
// l and r must have the same bit-vector sort.
func (l *Expr) BVSLT(r *Expr) *Expr {
	// Generated from bv.go:137.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvslt(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// BVULE returns the l <= r, where l and r are unsigned.
//
// l and r must have the same bit-vector sort.
func (l *Expr) BVULE(r *Expr) *Expr {
	// Generated from bv.go:143.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvule(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// BVSLE returns the l <= r, where l and r are signed.
//
// l and r must have the same bit-vector sort.
func (l *Expr) BVSLE(r *Expr) *Expr {
	// Generated from bv.go:149.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvsle(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// BVUGE returns the l >= r, where l and r are unsigned.
//
// l and r must have the same bit-vector sort.
func (l *Expr) BVUGE(r *Expr) *Expr {
	// Generated from bv.go:155.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvuge(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// BVSGE returns the l >= r, where l and r are signed.
//
// l and r must have the same bit-vector sort.
func (l *Expr) BVSGE(r *Expr) *Expr {
	// Generated from bv.go:161.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvsge(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// BVUGT returns the l > r, where l and r are unsigned.
//
// l and r must have the same bit-vector sort.
func (l *Expr) BVUGT(r *Expr) *Expr {
	// Generated from bv.go:167.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvugt(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// BVSGT returns the l > r, where l and r are signed.
//
// l and r must have the same bit-vector sort.
func (l *Expr) BVSGT(r *Expr) *Expr {
	// Generated from bv.go:173.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvsgt(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// BVConcat returns concatenation of l and r.
//
// l and r must have bit-vector sort. The result is a bit-vector whose
// length is the sum of the lengths of l and r.
func (l *Expr) BVConcat(r *Expr) *Expr {
	// Generated from bv.go:180.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_concat(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// BVExtract returns bits [high, low] (inclusive) of l, where bit 0 is
// the least significant bit.
//
// l must have bit-vector sort.
func (l *Expr) BVExtract(high int, low int) *Expr {
	// Generated from bv.go:187.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_extract(ctx.c, C.unsigned(high), C.unsigned(low), l.c)
	})
	runtime.KeepAlive(l)
	return wrapExpr(ctx, cexpr)
}

// BVSignExtend returns l sign-extended to a bit-vector of length m+i,
// where m is the length of l.
//
// l must have bit-vector sort.
func (l *Expr) BVSignExtend(i int) *Expr {
	// Generated from bv.go:194.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_sign_ext(ctx.c, C.unsigned(i), l.c)
	})
	runtime.KeepAlive(l)
	return wrapExpr(ctx, cexpr)
}

// BVZeroExtend returns l zero-extended to a bit-vector of length m+i,
// where m is the length of l.
//
// l must have bit-vector sort.
func (l *Expr) BVZeroExtend(i int) *Expr {
	// Generated from bv.go:201.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_zero_ext(ctx.c, C.unsigned(i), l.c)
	})
	runtime.KeepAlive(l)
	return wrapExpr(ctx, cexpr)
}

// BVRepeat returns l repeated up to length i.
//
// l must have bit-vector sort.
func (l *Expr) BVRepeat(i int) *Expr {
	// Generated from bv.go:207.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_repeat(ctx.c, C.unsigned(i), l.c)
	})
	runtime.KeepAlive(l)
	return wrapExpr(ctx, cexpr)
}

// BVShiftLeft returns l shifted left by i bits.
//
// This is equivalent to l * 2^i.
//
// l and i must have the same bit-vector sort. The result has the same
// sort.
func (l *Expr) BVShiftLeft(i *Expr) *Expr {
	// Generated from bv.go:216.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvshl(ctx.c, l.c, i.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(i)
	return wrapExpr(ctx, cexpr)
}

// BVShiftRightLogical returns l logically shifted right by i bits.
//
// This is equivalent to l / 2^i, where l and i are unsigned.
//
// l and i must have the same bit-vector sort. The result has the same
// sort.
func (l *Expr) BVShiftRightLogical(i *Expr) *Expr {
	// Generated from bv.go:225.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvlshr(ctx.c, l.c, i.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(i)
	return wrapExpr(ctx, cexpr)
}

// BVShiftRightArithmetic returns l arithmetically shifted right by i bits.
//
// This is like BVShiftRightLogical, but the sign of the result is the
// sign of l.
//
// l and i must have the same bit-vector sort. The result has the same
// sort.
func (l *Expr) BVShiftRightArithmetic(i *Expr) *Expr {
	// Generated from bv.go:235.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvashr(ctx.c, l.c, i.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(i)
	return wrapExpr(ctx, cexpr)
}

// BVRotateLeft returns l rotated left by i bits.
//
// l and i must have the same bit-vector sort.
func (l *Expr) BVRotateLeft(i *Expr) *Expr {
	// Generated from bv.go:241.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_ext_rotate_left(ctx.c, l.c, i.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(i)
	return wrapExpr(ctx, cexpr)
}

// BVRotateRight returns l rotated right by i bits.
//
// l and i must have the same bit-vector sort.
func (l *Expr) BVRotateRight(i *Expr) *Expr {
	// Generated from bv.go:247.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_ext_rotate_right(ctx.c, l.c, i.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(i)
	return wrapExpr(ctx, cexpr)
}

// Int2BV converts integer l to a bit-vector of width bits.
//
// l must have integer sort.
func (l *Expr) Int2BV(bits int) *Expr {
	// Generated from bv.go:253.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_int2bv(ctx.c, C.unsigned(bits), l.c)
	})
	runtime.KeepAlive(l)
	return wrapExpr(ctx, cexpr)
}

// BVS2Int converts signed bit-vector l to an integer.
//
// l must have bit-vector sort.
func (l *Expr) BVS2Int() *Expr {
	// Generated from bv.go:259.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bv2int(ctx.c, l.c, C.Z3_bool(1))
	})
	runtime.KeepAlive(l)
	return wrapExpr(ctx, cexpr)
}

// BVU2Int converts unsigned bit-vector l to an integer.
//
// l must have bit-vector sort.
func (l *Expr) BVU2Int() *Expr {
	// Generated from bv.go:265.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bv2int(ctx.c, l.c, C.Z3_bool(0))
	})
	runtime.KeepAlive(l)
	return wrapExpr(ctx, cexpr)
}
