// Generated by genwrap.go. DO NOT EDIT

package z3

import "runtime"

/*
#cgo LDFLAGS: -lz3
#include <z3.h>
#include <stdlib.h>
*/
import "C"

// Eq returns an expression that is true if l and r are equal.
func (l BV) Eq(r BV) Bool {
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_eq(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(wrapValue(ctx, cexpr))
}

// NE returns an expression that is true if l and r are not equal.
func (l BV) NE(r BV) Bool {
	return l.ctx.Distinct(l, r)
}

// Not returns the bit-wise negation of l.
func (l BV) Not() BV {
	// Generated from bv.go:117.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvnot(ctx.c, l.c)
	})
	runtime.KeepAlive(l)
	return BV(wrapValue(ctx, cexpr))
}

// And returns the bit-wise and of l and r.
//
// l and r must have the same size.
func (l BV) And(r BV) BV {
	// Generated from bv.go:123.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvand(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapValue(ctx, cexpr))
}

// Or returns the bit-wise or of l and r.
//
// l and r must have the same size.
func (l BV) Or(r BV) BV {
	// Generated from bv.go:129.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvor(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapValue(ctx, cexpr))
}

// Xor returns the bit-wise xor of l and r.
//
// l and r must have the same size.
func (l BV) Xor(r BV) BV {
	// Generated from bv.go:135.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvxor(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapValue(ctx, cexpr))
}

// Nand returns the bit-wise nand of l and r.
//
// l and r must have the same size.
func (l BV) Nand(r BV) BV {
	// Generated from bv.go:141.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvnand(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapValue(ctx, cexpr))
}

// Nor returns the bit-wise nor of l and r.
//
// l and r must have the same size.
func (l BV) Nor(r BV) BV {
	// Generated from bv.go:147.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvnor(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapValue(ctx, cexpr))
}

// Xnor returns the bit-wise xnor of l and r.
//
// l and r must have the same size.
func (l BV) Xnor(r BV) BV {
	// Generated from bv.go:153.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvxnor(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapValue(ctx, cexpr))
}

// Neg returns the two's complement negation of l.
func (l BV) Neg() BV {
	// Generated from bv.go:157.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvneg(ctx.c, l.c)
	})
	runtime.KeepAlive(l)
	return BV(wrapValue(ctx, cexpr))
}

// Add returns the two's complement sum of l and r.
//
// l and r must have the same size.
func (l BV) Add(r BV) BV {
	// Generated from bv.go:163.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvadd(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapValue(ctx, cexpr))
}

// Sub returns the two's complement subtraction l minus r.
//
// l and r must have the same size.
func (l BV) Sub(r BV) BV {
	// Generated from bv.go:169.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvsub(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapValue(ctx, cexpr))
}

// Mul returns the two's complement product of l and r.
//
// l and r must have the same size.
func (l BV) Mul(r BV) BV {
	// Generated from bv.go:175.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvmul(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapValue(ctx, cexpr))
}

// UDiv returns the unsigned quotient of l divided by r.
//
// l and r must have the same size.
func (l BV) UDiv(r BV) BV {
	// Generated from bv.go:181.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvudiv(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapValue(ctx, cexpr))
}

// SDiv returns the two's complement signed quotient of l divided by r.
//
// l and r must have the same size.
func (l BV) SDiv(r BV) BV {
	// Generated from bv.go:187.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvsdiv(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapValue(ctx, cexpr))
}

// URem returns the unsigned remainder of l divided by r.
//
// l and r must have the same size.
func (l BV) URem(r BV) BV {
	// Generated from bv.go:193.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvurem(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapValue(ctx, cexpr))
}

// SRem returns the two's complement signed remainder of l divided by r.
//
// The sign of the result follows the sign of l.
//
// l and r must have the same size.
func (l BV) SRem(r BV) BV {
	// Generated from bv.go:201.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvsrem(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapValue(ctx, cexpr))
}

// SMod returns the two's complement signed modulus of l divided by r.
//
// The sign of the result follows the sign of r.
//
// l and r must have the same size.
func (l BV) SMod(r BV) BV {
	// Generated from bv.go:209.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvsmod(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapValue(ctx, cexpr))
}

// ULT returns the l < r, where l and r are unsigned.
//
// l and r must have the same size.
func (l BV) ULT(r BV) Bool {
	// Generated from bv.go:215.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvult(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(wrapValue(ctx, cexpr))
}

// SLT returns the l < r, where l and r are signed.
//
// l and r must have the same size.
func (l BV) SLT(r BV) Bool {
	// Generated from bv.go:221.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvslt(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(wrapValue(ctx, cexpr))
}

// ULE returns the l <= r, where l and r are unsigned.
//
// l and r must have the same size.
func (l BV) ULE(r BV) Bool {
	// Generated from bv.go:227.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvule(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(wrapValue(ctx, cexpr))
}

// SLE returns the l <= r, where l and r are signed.
//
// l and r must have the same size.
func (l BV) SLE(r BV) Bool {
	// Generated from bv.go:233.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvsle(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(wrapValue(ctx, cexpr))
}

// UGE returns the l >= r, where l and r are unsigned.
//
// l and r must have the same size.
func (l BV) UGE(r BV) Bool {
	// Generated from bv.go:239.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvuge(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(wrapValue(ctx, cexpr))
}

// SGE returns the l >= r, where l and r are signed.
//
// l and r must have the same size.
func (l BV) SGE(r BV) Bool {
	// Generated from bv.go:245.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvsge(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(wrapValue(ctx, cexpr))
}

// UGT returns the l > r, where l and r are unsigned.
//
// l and r must have the same size.
func (l BV) UGT(r BV) Bool {
	// Generated from bv.go:251.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvugt(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(wrapValue(ctx, cexpr))
}

// SGT returns the l > r, where l and r are signed.
//
// l and r must have the same size.
func (l BV) SGT(r BV) Bool {
	// Generated from bv.go:257.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvsgt(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(wrapValue(ctx, cexpr))
}

// Concat returns concatenation of l and r.
//
// The result is a bit-vector whose length is the sum of the lengths
// of l and r.
func (l BV) Concat(r BV) BV {
	// Generated from bv.go:264.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_concat(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapValue(ctx, cexpr))
}

// Extract returns bits [high, low] (inclusive) of l, where bit 0 is
// the least significant bit.
func (l BV) Extract(high int, low int) BV {
	// Generated from bv.go:269.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_extract(ctx.c, C.unsigned(high), C.unsigned(low), l.c)
	})
	runtime.KeepAlive(l)
	return BV(wrapValue(ctx, cexpr))
}

// SignExtend returns l sign-extended to a bit-vector of length m+i,
// where m is the length of l.
func (l BV) SignExtend(i int) BV {
	// Generated from bv.go:274.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_sign_ext(ctx.c, C.unsigned(i), l.c)
	})
	runtime.KeepAlive(l)
	return BV(wrapValue(ctx, cexpr))
}

// ZeroExtend returns l zero-extended to a bit-vector of length m+i,
// where m is the length of l.
func (l BV) ZeroExtend(i int) BV {
	// Generated from bv.go:279.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_zero_ext(ctx.c, C.unsigned(i), l.c)
	})
	runtime.KeepAlive(l)
	return BV(wrapValue(ctx, cexpr))
}

// Repeat returns l repeated up to length i.
func (l BV) Repeat(i int) BV {
	// Generated from bv.go:283.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_repeat(ctx.c, C.unsigned(i), l.c)
	})
	runtime.KeepAlive(l)
	return BV(wrapValue(ctx, cexpr))
}

// Lsh returns l shifted left by i bits.
//
// This is equivalent to l * 2^i.
//
// l and i must have the same size. The result has the same sort.
func (l BV) Lsh(i BV) BV {
	// Generated from bv.go:291.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvshl(ctx.c, l.c, i.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(i)
	return BV(wrapValue(ctx, cexpr))
}

// URsh returns l logically shifted right by i bits.
//
// This is equivalent to l / 2^i, where l and i are unsigned.
//
// l and i must have the same size. The result has the same sort.
func (l BV) URsh(i BV) BV {
	// Generated from bv.go:299.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvlshr(ctx.c, l.c, i.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(i)
	return BV(wrapValue(ctx, cexpr))
}

// SRsh returns l arithmetically shifted right by i bits.
//
// This is like URsh, but the sign of the result is the sign of l.
//
// l and i must have the same size. The result has the same sort.
func (l BV) SRsh(i BV) BV {
	// Generated from bv.go:307.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvashr(ctx.c, l.c, i.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(i)
	return BV(wrapValue(ctx, cexpr))
}

// RotateLeft returns l rotated left by i bits.
//
// l and i must have the same size.
func (l BV) RotateLeft(i BV) BV {
	// Generated from bv.go:313.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_ext_rotate_left(ctx.c, l.c, i.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(i)
	return BV(wrapValue(ctx, cexpr))
}

// RotateRight returns l rotated right by i bits.
//
// l and i must have the same size.
func (l BV) RotateRight(i BV) BV {
	// Generated from bv.go:319.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_ext_rotate_right(ctx.c, l.c, i.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(i)
	return BV(wrapValue(ctx, cexpr))
}

// SToInt converts signed bit-vector l to an integer.
func (l BV) SToInt() Int {
	// Generated from bv.go:323.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bv2int(ctx.c, l.c, C.Z3_TRUE)
	})
	runtime.KeepAlive(l)
	return Int(wrapValue(ctx, cexpr))
}

// UToInt converts unsigned bit-vector l to an integer.
func (l BV) UToInt() Int {
	// Generated from bv.go:327.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bv2int(ctx.c, l.c, C.Z3_FALSE)
	})
	runtime.KeepAlive(l)
	return Int(wrapValue(ctx, cexpr))
}
