// Generated by genwrap.go. DO NOT EDIT

package z3

import "runtime"

/*
#cgo LDFLAGS: -lz3
#include <z3.h>
#include <stdlib.h>
*/
import "C"

// Eq returns an expression that is true if l and r are equal.
func (l BV) Eq(r BV) Bool {
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_eq(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(wrapExpr(ctx, cexpr))
}

// NE returns an expression that is true if l and r are not equal.
func (l BV) NE(r BV) Bool {
	return l.ctx.Distinct(l, r)
}

// Not returns the bit-wise negation of l.
func (l BV) Not() BV {
	// Generated from bv.go:142.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvnot(ctx.c, l.c)
	})
	runtime.KeepAlive(l)
	return BV(wrapExpr(ctx, cexpr))
}

// And returns the bit-wise and of l and r.
//
// l and r must have the same size.
func (l BV) And(r BV) BV {
	// Generated from bv.go:148.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvand(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapExpr(ctx, cexpr))
}

// Or returns the bit-wise or of l and r.
//
// l and r must have the same size.
func (l BV) Or(r BV) BV {
	// Generated from bv.go:154.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvor(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapExpr(ctx, cexpr))
}

// Xor returns the bit-wise xor of l and r.
//
// l and r must have the same size.
func (l BV) Xor(r BV) BV {
	// Generated from bv.go:160.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvxor(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapExpr(ctx, cexpr))
}

// Nand returns the bit-wise nand of l and r.
//
// l and r must have the same size.
func (l BV) Nand(r BV) BV {
	// Generated from bv.go:166.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvnand(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapExpr(ctx, cexpr))
}

// Nor returns the bit-wise nor of l and r.
//
// l and r must have the same size.
func (l BV) Nor(r BV) BV {
	// Generated from bv.go:172.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvnor(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapExpr(ctx, cexpr))
}

// Xnor returns the bit-wise xnor of l and r.
//
// l and r must have the same size.
func (l BV) Xnor(r BV) BV {
	// Generated from bv.go:178.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvxnor(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapExpr(ctx, cexpr))
}

// Neg returns the two's complement negation of l.
func (l BV) Neg() BV {
	// Generated from bv.go:182.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvneg(ctx.c, l.c)
	})
	runtime.KeepAlive(l)
	return BV(wrapExpr(ctx, cexpr))
}

// Add returns the two's complement sum of l and r.
//
// l and r must have the same size.
func (l BV) Add(r BV) BV {
	// Generated from bv.go:188.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvadd(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapExpr(ctx, cexpr))
}

// Sub returns the two's complement subtraction l minus r.
//
// l and r must have the same size.
func (l BV) Sub(r BV) BV {
	// Generated from bv.go:194.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvsub(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapExpr(ctx, cexpr))
}

// Mul returns the two's complement product of l and r.
//
// l and r must have the same size.
func (l BV) Mul(r BV) BV {
	// Generated from bv.go:200.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvmul(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapExpr(ctx, cexpr))
}

// UDiv returns the unsigned quotient of l divided by r.
//
// l and r must have the same size.
func (l BV) UDiv(r BV) BV {
	// Generated from bv.go:206.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvudiv(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapExpr(ctx, cexpr))
}

// SDiv returns the two's complement signed quotient of l divided by r.
//
// l and r must have the same size.
func (l BV) SDiv(r BV) BV {
	// Generated from bv.go:212.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvsdiv(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapExpr(ctx, cexpr))
}

// URem returns the unsigned remainder of l divided by r.
//
// l and r must have the same size.
func (l BV) URem(r BV) BV {
	// Generated from bv.go:218.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvurem(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapExpr(ctx, cexpr))
}

// SRem returns the two's complement signed remainder of l divided by r.
//
// The sign of the result follows the sign of l.
//
// l and r must have the same size.
func (l BV) SRem(r BV) BV {
	// Generated from bv.go:226.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvsrem(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapExpr(ctx, cexpr))
}

// SMod returns the two's complement signed modulus of l divided by r.
//
// The sign of the result follows the sign of r.
//
// l and r must have the same size.
func (l BV) SMod(r BV) BV {
	// Generated from bv.go:234.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvsmod(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapExpr(ctx, cexpr))
}

// ULT returns the l < r, where l and r are unsigned.
//
// l and r must have the same size.
func (l BV) ULT(r BV) Bool {
	// Generated from bv.go:240.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvult(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(wrapExpr(ctx, cexpr))
}

// SLT returns the l < r, where l and r are signed.
//
// l and r must have the same size.
func (l BV) SLT(r BV) Bool {
	// Generated from bv.go:246.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvslt(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(wrapExpr(ctx, cexpr))
}

// ULE returns the l <= r, where l and r are unsigned.
//
// l and r must have the same size.
func (l BV) ULE(r BV) Bool {
	// Generated from bv.go:252.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvule(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(wrapExpr(ctx, cexpr))
}

// SLE returns the l <= r, where l and r are signed.
//
// l and r must have the same size.
func (l BV) SLE(r BV) Bool {
	// Generated from bv.go:258.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvsle(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(wrapExpr(ctx, cexpr))
}

// UGE returns the l >= r, where l and r are unsigned.
//
// l and r must have the same size.
func (l BV) UGE(r BV) Bool {
	// Generated from bv.go:264.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvuge(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(wrapExpr(ctx, cexpr))
}

// SGE returns the l >= r, where l and r are signed.
//
// l and r must have the same size.
func (l BV) SGE(r BV) Bool {
	// Generated from bv.go:270.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvsge(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(wrapExpr(ctx, cexpr))
}

// UGT returns the l > r, where l and r are unsigned.
//
// l and r must have the same size.
func (l BV) UGT(r BV) Bool {
	// Generated from bv.go:276.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvugt(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(wrapExpr(ctx, cexpr))
}

// SGT returns the l > r, where l and r are signed.
//
// l and r must have the same size.
func (l BV) SGT(r BV) Bool {
	// Generated from bv.go:282.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvsgt(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(wrapExpr(ctx, cexpr))
}

// Concat returns concatenation of l and r.
//
// The result is a bit-vector whose length is the sum of the lengths
// of l and r.
func (l BV) Concat(r BV) BV {
	// Generated from bv.go:289.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_concat(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return BV(wrapExpr(ctx, cexpr))
}

// Extract returns bits [high, low] (inclusive) of l, where bit 0 is
// the least significant bit.
func (l BV) Extract(high int, low int) BV {
	// Generated from bv.go:294.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_extract(ctx.c, C.unsigned(high), C.unsigned(low), l.c)
	})
	runtime.KeepAlive(l)
	return BV(wrapExpr(ctx, cexpr))
}

// SignExtend returns l sign-extended to a bit-vector of length m+i,
// where m is the length of l.
func (l BV) SignExtend(i int) BV {
	// Generated from bv.go:299.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_sign_ext(ctx.c, C.unsigned(i), l.c)
	})
	runtime.KeepAlive(l)
	return BV(wrapExpr(ctx, cexpr))
}

// ZeroExtend returns l zero-extended to a bit-vector of length m+i,
// where m is the length of l.
func (l BV) ZeroExtend(i int) BV {
	// Generated from bv.go:304.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_zero_ext(ctx.c, C.unsigned(i), l.c)
	})
	runtime.KeepAlive(l)
	return BV(wrapExpr(ctx, cexpr))
}

// Repeat returns l repeated up to length i.
func (l BV) Repeat(i int) BV {
	// Generated from bv.go:308.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_repeat(ctx.c, C.unsigned(i), l.c)
	})
	runtime.KeepAlive(l)
	return BV(wrapExpr(ctx, cexpr))
}

// Lsh returns l shifted left by i bits.
//
// This is equivalent to l * 2^i.
//
// l and i must have the same size. The result has the same sort.
func (l BV) Lsh(i BV) BV {
	// Generated from bv.go:316.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvshl(ctx.c, l.c, i.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(i)
	return BV(wrapExpr(ctx, cexpr))
}

// URsh returns l logically shifted right by i bits.
//
// This is equivalent to l / 2^i, where l and i are unsigned.
//
// l and i must have the same size. The result has the same sort.
func (l BV) URsh(i BV) BV {
	// Generated from bv.go:324.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvlshr(ctx.c, l.c, i.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(i)
	return BV(wrapExpr(ctx, cexpr))
}

// SRsh returns l arithmetically shifted right by i bits.
//
// This is like URsh, but the sign of the result is the sign of l.
//
// l and i must have the same size. The result has the same sort.
func (l BV) SRsh(i BV) BV {
	// Generated from bv.go:332.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_bvashr(ctx.c, l.c, i.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(i)
	return BV(wrapExpr(ctx, cexpr))
}

// RotateLeft returns l rotated left by i bits.
//
// l and i must have the same size.
func (l BV) RotateLeft(i BV) BV {
	// Generated from bv.go:338.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_ext_rotate_left(ctx.c, l.c, i.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(i)
	return BV(wrapExpr(ctx, cexpr))
}

// RotateRight returns l rotated right by i bits.
//
// l and i must have the same size.
func (l BV) RotateRight(i BV) BV {
	// Generated from bv.go:344.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_ext_rotate_right(ctx.c, l.c, i.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(i)
	return BV(wrapExpr(ctx, cexpr))
}
