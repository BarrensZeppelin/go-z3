// Generated by genwrap.go. DO NOT EDIT

package z3

import "runtime"

/*
#cgo LDFLAGS: -lz3
#include <z3.h>
#include <stdlib.h>
*/
import "C"

// Eq returns a boolean expression that is true if l and r are equal.
//
// l and r must have the same sort.
func (l *Expr) Eq(r *Expr) *Expr {
	// Generated from logic.go:43.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_eq(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// Distinct returns a boolean expression that is true if no two exprs
// are equal.
//
// All expressions in exprs must have the same sort.
func (ctx *Context) Distinct(exprs ...*Expr) *Expr {
	// Generated from logic.go:50.
	cargs := make([]C.Z3_ast, len(exprs)+0)
	for i, arg := range exprs {
		cargs[i+0] = arg.c
	}
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_distinct(ctx.c, C.uint(len(cargs)), &cargs[0])
	})
	runtime.KeepAlive(&cargs[0])
	return wrapExpr(ctx, cexpr)
}

// Not returns the boolean negation of l.
//
// l must have boolean sort.
func (l *Expr) Not() *Expr {
	// Generated from logic.go:56.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_not(ctx.c, l.c)
	})
	runtime.KeepAlive(l)
	return wrapExpr(ctx, cexpr)
}

// IfThenElse returns an expression whose value is cons is cond is
// true, otherwise alt.
//
// cond must have boolean sort. cons and alt must have the same sort.
func (cond *Expr) IfThenElse(cons *Expr, alt *Expr) *Expr {
	// Generated from logic.go:63.
	ctx := cond.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_ite(ctx.c, cond.c, cons.c, alt.c)
	})
	runtime.KeepAlive(cond)
	runtime.KeepAlive(cons)
	runtime.KeepAlive(alt)
	return wrapExpr(ctx, cexpr)
}

// Iff returns an expression that is true if l and r are equal (l
// if-and-only-if r).
//
// l and r must have boolean sort.
func (l *Expr) Iff(r *Expr) *Expr {
	// Generated from logic.go:70.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_iff(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// Implies returns an expression that is true if l implies r.
//
// l and r must have boolean sort.
func (l *Expr) Implies(r *Expr) *Expr {
	// Generated from logic.go:76.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_implies(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// Xor returns an expression that is true if l xor r.
//
// l and r must have boolean sort.
func (l *Expr) Xor(r *Expr) *Expr {
	// Generated from logic.go:82.
	ctx := l.ctx
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_xor(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return wrapExpr(ctx, cexpr)
}

// And returns an expression that is true if l and all arguments are
// true.
//
// All arguments must have boolean sort.
func (l *Expr) And(r ...*Expr) *Expr {
	// Generated from logic.go:89.
	ctx := l.ctx
	cargs := make([]C.Z3_ast, len(r)+1)
	cargs[0] = l.c
	for i, arg := range r {
		cargs[i+1] = arg.c
	}
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_and(ctx.c, C.uint(len(cargs)), &cargs[0])
	})
	runtime.KeepAlive(&cargs[0])
	return wrapExpr(ctx, cexpr)
}

// Or returns an expression that is true if l or any argument is true.
//
// All arguments must have boolean sort.
func (l *Expr) Or(r ...*Expr) *Expr {
	// Generated from logic.go:95.
	ctx := l.ctx
	cargs := make([]C.Z3_ast, len(r)+1)
	cargs[0] = l.c
	for i, arg := range r {
		cargs[i+1] = arg.c
	}
	var cexpr C.Z3_ast
	ctx.do(func() {
		cexpr = C.Z3_mk_or(ctx.c, C.uint(len(cargs)), &cargs[0])
	})
	runtime.KeepAlive(&cargs[0])
	return wrapExpr(ctx, cexpr)
}
